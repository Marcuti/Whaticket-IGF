"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = __importDefault(require("url"));
const bb_got_wrapper_1 = __importDefault(require("./bb-got-wrapper"));
function repoInfoTransformer(repoInfoBody) {
    return {
        privateRepo: repoInfoBody.is_private,
        isFork: !!repoInfoBody.parent,
        repoFullName: repoInfoBody.full_name,
        owner: repoInfoBody.owner.username,
        mainbranch: repoInfoBody.mainbranch.name,
        mergeMethod: 'merge',
    };
}
exports.repoInfoTransformer = repoInfoTransformer;
exports.prStates = {
    open: ['OPEN'],
    notOpen: ['MERGED', 'DECLINED', 'SUPERSEDED'],
    merged: ['MERGED'],
    closed: ['DECLINED', 'SUPERSEDED'],
    all: ['OPEN', 'MERGED', 'DECLINED', 'SUPERSEDED'],
};
exports.buildStates = {
    success: 'SUCCESSFUL',
    failed: 'FAILED',
    pending: 'INPROGRESS',
};
const addMaxLength = (inputUrl, pagelen = 100) => {
    const { search, ...parsedUrl } = url_1.default.parse(inputUrl, true); // eslint-disable-line @typescript-eslint/no-unused-vars
    const maxedUrl = url_1.default.format({
        ...parsedUrl,
        query: { ...parsedUrl.query, pagelen },
    });
    return maxedUrl;
};
async function accumulateValues(reqUrl, method = 'get', options, pagelen) {
    let accumulator = [];
    let nextUrl = addMaxLength(reqUrl, pagelen);
    const lowerCaseMethod = method.toLocaleLowerCase();
    while (typeof nextUrl !== 'undefined') {
        const { body } = await bb_got_wrapper_1.default[lowerCaseMethod](nextUrl, options);
        accumulator = [...accumulator, ...body.values];
        nextUrl = body.next;
    }
    return accumulator;
}
exports.accumulateValues = accumulateValues;
// istanbul ignore next
function isConflicted(files) {
    for (const file of files) {
        for (const chunk of file.chunks) {
            for (const change of chunk.changes) {
                if (change.content === '+=======') {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.isConflicted = isConflicted;
function prInfo(pr) {
    return {
        number: pr.id,
        body: pr.summary ? pr.summary.raw : /* istanbul ignore next */ undefined,
        branchName: pr.source.branch.name,
        title: pr.title,
        state: exports.prStates.closed.includes(pr.state)
            ? /* istanbul ignore next */ 'closed'
            : pr.state.toLowerCase(),
        createdAt: pr.created_on,
    };
}
exports.prInfo = prInfo;
