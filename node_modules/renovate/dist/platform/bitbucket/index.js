"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const parse_diff_1 = __importDefault(require("parse-diff"));
const bb_got_wrapper_1 = __importDefault(require("./bb-got-wrapper"));
const utils = __importStar(require("./utils"));
const hostRules = __importStar(require("../../util/host-rules"));
const storage_1 = __importDefault(require("../git/storage"));
const read_only_issue_body_1 = require("../utils/read-only-issue-body");
const app_strings_1 = require("../../config/app-strings");
let config = {};
function initPlatform({ endpoint, username, password, }) {
    if (!(username && password)) {
        throw new Error('Init: You must configure a Bitbucket username and password');
    }
    if (endpoint && endpoint !== 'https://api.bitbucket.org/') {
        throw new Error('Init: Bitbucket Cloud endpoint can only be https://api.bitbucket.org/');
    }
    // TODO: Add a connection check that endpoint/username/password combination are valid
    const res = {
        endpoint: 'https://api.bitbucket.org/',
    };
    logger.info('Using default Bitbucket Cloud endpoint: ' + res.endpoint);
    return res;
}
exports.initPlatform = initPlatform;
// Get all repositories that the user has access to
async function getRepos() {
    logger.info('Autodiscovering Bitbucket Cloud repositories');
    try {
        const repos = await utils.accumulateValues(`/2.0/repositories/?role=contributor`);
        return repos.map((repo) => repo.full_name);
    }
    catch (err) /* istanbul ignore next */ {
        logger.error({ err }, `bitbucket getRepos error`);
        throw err;
    }
}
exports.getRepos = getRepos;
// Initialize bitbucket by getting base branch and SHA
async function initRepo({ repository, localDir, }) {
    logger.debug(`initRepo("${repository}")`);
    const opts = hostRules.find({ hostType: 'bitbucket' });
    bb_got_wrapper_1.default.reset();
    config = {};
    // TODO: get in touch with @rarkins about lifting up the caching into the app layer
    config.repository = repository;
    const platformConfig = {};
    // Always gitFs
    const url = storage_1.default.getUrl({
        gitFs: 'https',
        auth: `${opts.username}:${opts.password}`,
        hostname: 'bitbucket.org',
        repository,
    });
    config.storage = new storage_1.default();
    await config.storage.initRepo({
        ...config,
        localDir,
        url,
    });
    try {
        const info = utils.repoInfoTransformer((await bb_got_wrapper_1.default.get(`/2.0/repositories/${repository}`)).body);
        platformConfig.privateRepo = info.privateRepo;
        platformConfig.isFork = info.isFork;
        platformConfig.repoFullName = info.repoFullName;
        config.owner = info.owner;
        logger.debug(`${repository} owner = ${config.owner}`);
        config.defaultBranch = info.mainbranch;
        config.baseBranch = config.defaultBranch;
        config.mergeMethod = info.mergeMethod;
    }
    catch (err) /* istanbul ignore next */ {
        if (err.statusCode === 404) {
            throw new Error('not-found');
        }
        logger.info({ err }, 'Unknown Bitbucket initRepo error');
        throw err;
    }
    delete config.prList;
    delete config.fileList;
    await Promise.all([getPrList(), getFileList()]);
    return platformConfig;
}
exports.initRepo = initRepo;
// Returns true if repository has rule enforcing PRs are up-to-date with base branch before merging
function getRepoForceRebase() {
    // BB doesnt have an option to flag staled branches
    return false;
}
exports.getRepoForceRebase = getRepoForceRebase;
async function setBaseBranch(branchName = config.baseBranch) {
    logger.debug(`Setting baseBranch to ${branchName}`);
    config.baseBranch = branchName;
    delete config.baseCommitSHA;
    delete config.fileList;
    await config.storage.setBaseBranch(branchName);
    await getFileList(branchName);
}
exports.setBaseBranch = setBaseBranch;
// istanbul ignore next
function setBranchPrefix(branchPrefix) {
    return config.storage.setBranchPrefix(branchPrefix);
}
exports.setBranchPrefix = setBranchPrefix;
// Search
// Get full file list
function getFileList(branchName) {
    return config.storage.getFileList(branchName);
}
exports.getFileList = getFileList;
// Branch
// Returns true if branch exists, otherwise false
function branchExists(branchName) {
    return config.storage.branchExists(branchName);
}
exports.branchExists = branchExists;
function getAllRenovateBranches(branchPrefix) {
    return config.storage.getAllRenovateBranches(branchPrefix);
}
exports.getAllRenovateBranches = getAllRenovateBranches;
function isBranchStale(branchName) {
    return config.storage.isBranchStale(branchName);
}
exports.isBranchStale = isBranchStale;
function getFile(filePath, branchName) {
    return config.storage.getFile(filePath, branchName);
}
exports.getFile = getFile;
async function deleteBranch(branchName, closePr) {
    if (closePr) {
        const pr = await findPr(branchName, null, 'open');
        if (pr) {
            await bb_got_wrapper_1.default.post(`/2.0/repositories/${config.repository}/pullrequests/${pr.number}/decline`);
        }
    }
    return config.storage.deleteBranch(branchName);
}
exports.deleteBranch = deleteBranch;
function getBranchLastCommitTime(branchName) {
    return config.storage.getBranchLastCommitTime(branchName);
}
exports.getBranchLastCommitTime = getBranchLastCommitTime;
// istanbul ignore next
function getRepoStatus() {
    return config.storage.getRepoStatus();
}
exports.getRepoStatus = getRepoStatus;
function mergeBranch(branchName) {
    return config.storage.mergeBranch(branchName);
}
exports.mergeBranch = mergeBranch;
function commitFilesToBranch(branchName, files, message, parentBranch = config.baseBranch) {
    return config.storage.commitFilesToBranch(branchName, files, message, parentBranch);
}
exports.commitFilesToBranch = commitFilesToBranch;
function getCommitMessages() {
    return config.storage.getCommitMessages();
}
exports.getCommitMessages = getCommitMessages;
// Returns the Pull Request for a branch. Null if not exists.
async function getBranchPr(branchName) {
    logger.debug(`getBranchPr(${branchName})`);
    const existingPr = await findPr(branchName, null, 'open');
    return existingPr ? getPr(existingPr.number) : null;
}
exports.getBranchPr = getBranchPr;
// Returns the combined status for a branch.
async function getBranchStatus(branchName, requiredStatusChecks) {
    logger.debug(`getBranchStatus(${branchName})`);
    if (!requiredStatusChecks) {
        // null means disable status checks, so it always succeeds
        logger.debug('Status checks disabled = returning "success"');
        return 'success';
    }
    if (requiredStatusChecks.length) {
        // This is Unsupported
        logger.warn({ requiredStatusChecks }, `Unsupported requiredStatusChecks`);
        return 'failed';
    }
    const sha = await getBranchCommit(branchName);
    const statuses = await utils.accumulateValues(`/2.0/repositories/${config.repository}/commit/${sha}/statuses`);
    const noOfFailures = statuses.filter((status) => status.state === 'FAILED').length;
    logger.debug({ branch: branchName, sha, statuses }, 'branch status check result');
    if (noOfFailures) {
        return 'failed';
    }
    return 'success';
}
exports.getBranchStatus = getBranchStatus;
async function getBranchStatusCheck(branchName, context) {
    const sha = await getBranchCommit(branchName);
    const statuses = await utils.accumulateValues(`/2.0/repositories/${config.repository}/commit/${sha}/statuses`);
    const bbState = (statuses.find((status) => status.key === context) || {}).state;
    return (Object.keys(utils.buildStates).find(stateKey => utils.buildStates[stateKey] === bbState) || null);
}
exports.getBranchStatusCheck = getBranchStatusCheck;
async function setBranchStatus(branchName, context, description, state, targetUrl) {
    const sha = await getBranchCommit(branchName);
    // TargetUrl can not be empty so default to bitbucket
    const url = targetUrl || /* istanbul ignore next */ 'http://bitbucket.org';
    const body = {
        name: context,
        state: utils.buildStates[state],
        key: context,
        description,
        url,
    };
    await bb_got_wrapper_1.default.post(`/2.0/repositories/${config.repository}/commit/${sha}/statuses/build`, { body });
}
exports.setBranchStatus = setBranchStatus;
async function findOpenIssues(title) {
    try {
        const currentUser = (await bb_got_wrapper_1.default.get('/2.0/user')).body.username;
        const filter = encodeURIComponent([
            `title=${JSON.stringify(title)}`,
            '(state = "new" OR state = "open")',
            `reporter.username="${currentUser}"`,
        ].join(' AND '));
        return ((await bb_got_wrapper_1.default.get(`/2.0/repositories/${config.repository}/issues?q=${filter}`)).body.values || /* istanbul ignore next */ []);
    }
    catch (err) /* istanbul ignore next */ {
        logger.warn('Error finding issues');
        return [];
    }
}
async function findIssue(title) {
    logger.debug(`findIssue(${title})`);
    const issues = await findOpenIssues(title);
    if (!issues.length) {
        return null;
    }
    const [issue] = issues;
    return {
        number: issue.id,
        body: issue.content && issue.content.raw,
    };
}
exports.findIssue = findIssue;
async function closeIssue(issueNumber) {
    await bb_got_wrapper_1.default.put(`/2.0/repositories/${config.repository}/issues/${issueNumber}`, {
        body: { state: 'closed' },
    });
}
async function ensureIssue(title, body) {
    logger.debug(`ensureIssue()`);
    try {
        const issues = await findOpenIssues(title);
        if (issues.length) {
            // Close any duplicates
            for (const issue of issues.slice(1)) {
                await closeIssue(issue.id);
            }
            const [issue] = issues;
            if (String(issue.content.raw).trim() !== body.trim()) {
                logger.info('Issue updated');
                await bb_got_wrapper_1.default.put(`/2.0/repositories/${config.repository}/issues/${issue.id}`, {
                    body: {
                        content: { raw: read_only_issue_body_1.readOnlyIssueBody(body), markup: 'markdown' },
                    },
                });
                return 'updated';
            }
        }
        else {
            logger.info('Issue created');
            await bb_got_wrapper_1.default.post(`/2.0/repositories/${config.repository}/issues`, {
                body: {
                    title,
                    content: { raw: read_only_issue_body_1.readOnlyIssueBody(body), markup: 'markdown' },
                },
            });
            return 'created';
        }
    }
    catch (err) /* istanbul ignore next */ {
        if (err.message.startsWith('Repository has no issue tracker.')) {
            logger.info(`Issues are disabled, so could not create issue: ${err.message}`);
        }
        else {
            logger.warn({ err }, 'Could not ensure issue');
        }
    }
    return null;
}
exports.ensureIssue = ensureIssue;
// istanbul ignore next
function getIssueList() {
    logger.debug(`getIssueList()`);
    // TODO: Needs implementation
    return [];
}
exports.getIssueList = getIssueList;
async function ensureIssueClosing(title) {
    const issues = await findOpenIssues(title);
    for (const issue of issues) {
        await closeIssue(issue.id);
    }
}
exports.ensureIssueClosing = ensureIssueClosing;
function addAssignees(_prNr, _assignees) {
    // Bitbucket supports "participants" and "reviewers" so does not seem to have the concept of "assignee"
    logger.warn('Cannot add assignees');
    return Promise.resolve();
}
exports.addAssignees = addAssignees;
async function addReviewers(prId, reviewers) {
    logger.debug(`Adding reviewers ${reviewers} to #${prId}`);
    const { title } = await getPr(prId);
    const body = {
        title,
        reviewers: reviewers.map((username) => ({ username })),
    };
    await bb_got_wrapper_1.default.put(`/2.0/repositories/${config.repository}/pullrequests/${prId}`, {
        body,
    });
}
exports.addReviewers = addReviewers;
// istanbul ignore next
function deleteLabel() {
    throw new Error('deleteLabel not implemented');
}
exports.deleteLabel = deleteLabel;
function ensureComment(_prNo, _topic, _content) {
    // https://developer.atlassian.com/bitbucket/api/2/reference/search?q=pullrequest+comment
    logger.warn('Comment functionality not implemented yet');
    return Promise.resolve();
}
exports.ensureComment = ensureComment;
function ensureCommentRemoval(_prNo, _topic) {
    // The api does not support removing comments
    return Promise.resolve();
}
exports.ensureCommentRemoval = ensureCommentRemoval;
// istanbul ignore next
function matchesState(state, desiredState) {
    if (desiredState === 'all') {
        return true;
    }
    if (desiredState[0] === '!') {
        return state !== desiredState.substring(1);
    }
    return state === desiredState;
}
async function findPr(branchName, prTitle, state = 'all') {
    logger.debug(`findPr(${branchName}, ${prTitle}, ${state})`);
    const prList = await getPrList();
    const pr = prList.find((p) => p.branchName === branchName &&
        (!prTitle || p.title === prTitle) &&
        matchesState(p.state, state));
    if (pr) {
        logger.debug(`Found PR #${pr.number}`);
    }
    return pr;
}
exports.findPr = findPr;
// Creates PR and returns PR number
async function createPr(branchName, title, description, _labels, useDefaultBranch = true) {
    // labels is not supported in Bitbucket: https://bitbucket.org/site/master/issues/11976/ability-to-add-labels-to-pull-requests-bb
    const base = useDefaultBranch
        ? config.defaultBranch
        : /* istanbul ignore next */ config.baseBranch;
    logger.debug({ repository: config.repository, title, base }, 'Creating PR');
    const body = {
        title,
        description,
        source: {
            branch: {
                name: branchName,
            },
        },
        destination: {
            branch: {
                name: base,
            },
        },
        close_source_branch: true,
    };
    const prInfo = (await bb_got_wrapper_1.default.post(`/2.0/repositories/${config.repository}/pullrequests`, { body })).body;
    const pr = { number: prInfo.id, displayNumber: `Pull Request #${prInfo.id}` };
    // istanbul ignore if
    if (config.prList) {
        config.prList.push(pr);
    }
    return pr;
}
exports.createPr = createPr;
async function isPrConflicted(prNo) {
    const diff = (await bb_got_wrapper_1.default.get(`/2.0/repositories/${config.repository}/pullrequests/${prNo}/diff`, { json: false })).body;
    return utils.isConflicted(parse_diff_1.default(diff));
}
// Gets details for a PR
async function getPr(prNo) {
    const pr = (await bb_got_wrapper_1.default.get(`/2.0/repositories/${config.repository}/pullrequests/${prNo}`)).body;
    // istanbul ignore if
    if (!pr) {
        return null;
    }
    const res = {
        displayNumber: `Pull Request #${pr.id}`,
        ...utils.prInfo(pr),
    };
    if (utils.prStates.open.includes(pr.state)) {
        res.isConflicted = await isPrConflicted(prNo);
        const commits = await utils.accumulateValues(pr.links.commits.href);
        if (commits.length === 1) {
            res.canRebase = true;
        }
    }
    if (await branchExists(pr.source.branch.name)) {
        res.isStale = await isBranchStale(pr.source.branch.name);
    }
    return res;
}
exports.getPr = getPr;
// Return a list of all modified files in a PR
async function getPrFiles(prNo) {
    logger.debug({ prNo }, 'getPrFiles');
    const diff = (await bb_got_wrapper_1.default.get(`/2.0/repositories/${config.repository}/pullrequests/${prNo}/diff`, { json: false })).body;
    const files = parse_diff_1.default(diff).map(file => file.to);
    return files;
}
exports.getPrFiles = getPrFiles;
async function updatePr(prNo, title, description) {
    logger.debug(`updatePr(${prNo}, ${title}, body)`);
    await bb_got_wrapper_1.default.put(`/2.0/repositories/${config.repository}/pullrequests/${prNo}`, {
        body: { title, description },
    });
}
exports.updatePr = updatePr;
async function mergePr(prNo, branchName) {
    logger.debug(`mergePr(${prNo}, ${branchName})`);
    try {
        await bb_got_wrapper_1.default.post(`/2.0/repositories/${config.repository}/pullrequests/${prNo}/merge`, {
            body: {
                close_source_branch: true,
                merge_strategy: 'merge_commit',
                message: 'auto merged',
            },
        });
        delete config.baseCommitSHA;
        logger.info('Automerging succeeded');
    }
    catch (err) /* istanbul ignore next */ {
        return false;
    }
    return true;
}
exports.mergePr = mergePr;
function getPrBody(input) {
    // Remove any HTML we use
    return input
        .replace(/<\/?summary>/g, '**')
        .replace(/<\/?details>/g, '')
        .replace(new RegExp(`\n---\n\n.*?<!-- ${app_strings_1.appSlug}-rebase -->.*?\n`), '')
        .substring(0, 50000);
}
exports.getPrBody = getPrBody;
// Return the commit SHA for a branch
async function getBranchCommit(branchName) {
    try {
        const branch = (await bb_got_wrapper_1.default.get(`/2.0/repositories/${config.repository}/refs/branches/${branchName}`)).body;
        return branch.target.hash;
    }
    catch (err) /* istanbul ignore next */ {
        logger.debug({ err }, `getBranchCommit('${branchName}') failed'`);
        return null;
    }
}
// Pull Request
async function getPrList() {
    logger.debug('getPrList()');
    if (!config.prList) {
        logger.debug('Retrieving PR list');
        let url = `/2.0/repositories/${config.repository}/pullrequests?`;
        url += utils.prStates.all.map(state => 'state=' + state).join('&');
        const prs = await utils.accumulateValues(url, undefined, undefined, 50);
        config.prList = prs.map(utils.prInfo);
        logger.info({ length: config.prList.length }, 'Retrieved Pull Requests');
    }
    return config.prList;
}
exports.getPrList = getPrList;
function cleanRepo() {
    // istanbul ignore if
    if (config.storage && config.storage.cleanRepo) {
        config.storage.cleanRepo();
    }
    bb_got_wrapper_1.default.reset();
    config = {};
}
exports.cleanRepo = cleanRepo;
function getVulnerabilityAlerts() {
    return [];
}
exports.getVulnerabilityAlerts = getVulnerabilityAlerts;
